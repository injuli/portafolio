{"ast":null,"code":"import _asyncToGenerator from \"D:/Ingrid/Documentos/portafolio/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Circle, ExternalInteractorBase, Vector, clamp, getDistances, getEasing, isInArray, mouseMoveEvent } from \"tsparticles-engine\";\nimport { Attract } from \"./Options/Classes/Attract\";\nexport class Attractor extends ExternalInteractorBase {\n  constructor(engine, container) {\n    super(container);\n    this._clickAttract = () => {\n      const container = this.container;\n      if (!container.attract) {\n        container.attract = {\n          particles: []\n        };\n      }\n      const {\n        attract\n      } = container;\n      if (!attract.finish) {\n        if (!attract.count) {\n          attract.count = 0;\n        }\n        attract.count++;\n        if (attract.count === container.particles.count) {\n          attract.finish = true;\n        }\n      }\n      if (attract.clicking) {\n        const mousePos = container.interactivity.mouse.clickPosition,\n          attractRadius = container.retina.attractModeDistance;\n        if (!attractRadius || attractRadius < 0 || !mousePos) {\n          return;\n        }\n        this._processAttract(mousePos, attractRadius, new Circle(mousePos.x, mousePos.y, attractRadius));\n      } else if (attract.clicking === false) {\n        attract.particles = [];\n      }\n      return;\n    };\n    this._hoverAttract = () => {\n      const container = this.container,\n        mousePos = container.interactivity.mouse.position,\n        attractRadius = container.retina.attractModeDistance;\n      if (!attractRadius || attractRadius < 0 || !mousePos) {\n        return;\n      }\n      this._processAttract(mousePos, attractRadius, new Circle(mousePos.x, mousePos.y, attractRadius));\n    };\n    this._processAttract = (position, attractRadius, area) => {\n      const container = this.container,\n        attractOptions = container.actualOptions.interactivity.modes.attract;\n      if (!attractOptions) {\n        return;\n      }\n      const query = container.particles.quadTree.query(area, p => this.isEnabled(p));\n      for (const particle of query) {\n        const {\n          dx,\n          dy,\n          distance\n        } = getDistances(particle.position, position);\n        const velocity = attractOptions.speed * attractOptions.factor;\n        const attractFactor = clamp(getEasing(attractOptions.easing)(1 - distance / attractRadius) * velocity, 0, attractOptions.maxSpeed);\n        const normVec = Vector.create(distance === 0 ? velocity : dx / distance * attractFactor, distance === 0 ? velocity : dy / distance * attractFactor);\n        particle.position.subFrom(normVec);\n      }\n    };\n    this._engine = engine;\n    if (!container.attract) {\n      container.attract = {\n        particles: []\n      };\n    }\n    this.handleClickMode = mode => {\n      const options = this.container.actualOptions,\n        attract = options.interactivity.modes.attract;\n      if (!attract || mode !== \"attract\") {\n        return;\n      }\n      if (!container.attract) {\n        container.attract = {\n          particles: []\n        };\n      }\n      container.attract.clicking = true;\n      container.attract.count = 0;\n      for (const particle of container.attract.particles) {\n        if (!this.isEnabled(particle)) {\n          continue;\n        }\n        particle.velocity.setTo(particle.initialVelocity);\n      }\n      container.attract.particles = [];\n      container.attract.finish = false;\n      setTimeout(() => {\n        if (container.destroyed) {\n          return;\n        }\n        if (!container.attract) {\n          container.attract = {\n            particles: []\n          };\n        }\n        container.attract.clicking = false;\n      }, attract.duration * 1000);\n    };\n  }\n  clear() {}\n  init() {\n    const container = this.container,\n      attract = container.actualOptions.interactivity.modes.attract;\n    if (!attract) {\n      return;\n    }\n    container.retina.attractModeDistance = attract.distance * container.retina.pixelRatio;\n  }\n  interact() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const container = _this.container,\n        options = container.actualOptions,\n        mouseMoveStatus = container.interactivity.status === mouseMoveEvent,\n        events = options.interactivity.events,\n        hoverEnabled = events.onHover.enable,\n        hoverMode = events.onHover.mode,\n        clickEnabled = events.onClick.enable,\n        clickMode = events.onClick.mode;\n      if (mouseMoveStatus && hoverEnabled && isInArray(\"attract\", hoverMode)) {\n        _this._hoverAttract();\n      } else if (clickEnabled && isInArray(\"attract\", clickMode)) {\n        _this._clickAttract();\n      }\n    })();\n  }\n  isEnabled(particle) {\n    const container = this.container,\n      options = container.actualOptions,\n      mouse = container.interactivity.mouse,\n      events = (particle?.interactivity ?? options.interactivity).events;\n    if ((!mouse.position || !events.onHover.enable) && (!mouse.clickPosition || !events.onClick.enable)) {\n      return false;\n    }\n    const hoverMode = events.onHover.mode,\n      clickMode = events.onClick.mode;\n    return isInArray(\"attract\", hoverMode) || isInArray(\"attract\", clickMode);\n  }\n  loadModeOptions(options, ...sources) {\n    if (!options.attract) {\n      options.attract = new Attract();\n    }\n    for (const source of sources) {\n      options.attract.load(source?.attract);\n    }\n  }\n  reset() {}\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}