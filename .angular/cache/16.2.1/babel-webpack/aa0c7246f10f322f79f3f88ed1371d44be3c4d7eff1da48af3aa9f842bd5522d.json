{"ast":null,"code":"import _asyncToGenerator from \"D:/Ingrid/Documentos/portafolio/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { errorPrefix } from \"tsparticles-engine\";\nimport { replaceImageColor } from \"./Utils\";\nexport class ImageDrawer {\n  constructor(engine) {\n    var _this = this,\n      _ref;\n    this.loadImageShape = function (_x) {\n      return (_ref = _ref || _asyncToGenerator(function* (imageShape) {\n        if (!_this._engine.loadImage) {\n          throw new Error(`${errorPrefix} image shape not initialized`);\n        }\n        yield _this._engine.loadImage({\n          gif: imageShape.gif,\n          name: imageShape.name,\n          replaceColor: imageShape.replaceColor ?? imageShape.replace_color ?? false,\n          src: imageShape.src\n        });\n      })).apply(this, arguments);\n    };\n    this._engine = engine;\n  }\n  addImage(image) {\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    this._engine.images.push(image);\n  }\n  draw(context, particle, radius, opacity, delta) {\n    const image = particle.image,\n      element = image?.element;\n    if (!image) {\n      return;\n    }\n    context.globalAlpha = opacity;\n    if (image.gif && image.gifData) {\n      const offscreenCanvas = new OffscreenCanvas(image.gifData.width, image.gifData.height),\n        offscreenContext = offscreenCanvas.getContext(\"2d\");\n      if (!offscreenContext) {\n        throw new Error(\"could not create offscreen canvas context\");\n      }\n      offscreenContext.imageSmoothingQuality = \"low\";\n      offscreenContext.imageSmoothingEnabled = false;\n      offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n      if (particle.gifLoopCount === undefined) {\n        particle.gifLoopCount = image.gifLoopCount ?? 0;\n      }\n      let frameIndex = particle.gifFrame ?? 0;\n      const pos = {\n          x: -image.gifData.width * 0.5,\n          y: -image.gifData.height * 0.5\n        },\n        frame = image.gifData.frames[frameIndex];\n      if (particle.gifTime === undefined) {\n        particle.gifTime = 0;\n      }\n      if (!frame.bitmap) {\n        return;\n      }\n      context.scale(radius / image.gifData.width, radius / image.gifData.height);\n      switch (frame.disposalMethod) {\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 0:\n          offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n          context.drawImage(offscreenCanvas, pos.x, pos.y);\n          offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n          break;\n        case 1:\n          offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n          context.drawImage(offscreenCanvas, pos.x, pos.y);\n          break;\n        case 2:\n          offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n          context.drawImage(offscreenCanvas, pos.x, pos.y);\n          offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n          if (image.gifData.globalColorTable.length === 0) {\n            offscreenContext.putImageData(image.gifData.frames[0].image, pos.x + frame.left, pos.y + frame.top);\n          } else {\n            offscreenContext.putImageData(image.gifData.backgroundImage, pos.x, pos.y);\n          }\n          break;\n        case 3:\n          {\n            const previousImageData = offscreenContext.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n            offscreenContext.putImageData(previousImageData, 0, 0);\n          }\n          break;\n      }\n      particle.gifTime += delta.value;\n      if (particle.gifTime > frame.delayTime) {\n        particle.gifTime -= frame.delayTime;\n        if (++frameIndex >= image.gifData.frames.length) {\n          if (--particle.gifLoopCount <= 0) {\n            return;\n          }\n          frameIndex = 0;\n          offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n        }\n        particle.gifFrame = frameIndex;\n      }\n      context.scale(image.gifData.width / radius, image.gifData.height / radius);\n    } else if (element) {\n      const ratio = image.ratio,\n        pos = {\n          x: -radius,\n          y: -radius\n        };\n      context.drawImage(element, pos.x, pos.y, radius * 2, radius * 2 / ratio);\n    }\n    context.globalAlpha = 1;\n  }\n  getSidesCount() {\n    return 12;\n  }\n  init(container) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const options = container.actualOptions;\n      if (!options.preload || !_this2._engine.loadImage) {\n        return;\n      }\n      for (const imageData of options.preload) {\n        yield _this2._engine.loadImage(imageData);\n      }\n    })();\n  }\n  loadShape(particle) {\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    const imageData = particle.shapeData,\n      image = this._engine.images.find(t => t.name === imageData.name || t.source === imageData.src);\n    if (!image) {\n      this.loadImageShape(imageData).then(() => {\n        this.loadShape(particle);\n      });\n    }\n  }\n  particleInit(container, particle) {\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    const images = this._engine.images,\n      imageData = particle.shapeData,\n      color = particle.getFillColor(),\n      image = images.find(t => t.name === imageData.name || t.source === imageData.src);\n    if (!image) {\n      return;\n    }\n    const replaceColor = imageData.replaceColor ?? imageData.replace_color ?? image.replaceColor;\n    if (image.loading) {\n      setTimeout(() => {\n        this.particleInit(container, particle);\n      });\n      return;\n    }\n    _asyncToGenerator(function* () {\n      let imageRes;\n      if (image.svgData && color) {\n        imageRes = yield replaceImageColor(image, imageData, color, particle);\n      } else {\n        imageRes = {\n          color,\n          data: image,\n          element: image.element,\n          gif: image.gif,\n          gifData: image.gifData,\n          gifLoopCount: image.gifLoopCount,\n          loaded: true,\n          ratio: imageData.width && imageData.height ? imageData.width / imageData.height : image.ratio ?? 1,\n          replaceColor: replaceColor,\n          source: imageData.src\n        };\n      }\n      if (!imageRes.ratio) {\n        imageRes.ratio = 1;\n      }\n      const fill = imageData.fill ?? particle.fill,\n        close = imageData.close ?? particle.close,\n        imageShape = {\n          image: imageRes,\n          fill,\n          close\n        };\n      particle.image = imageShape.image;\n      particle.fill = imageShape.fill;\n      particle.close = imageShape.close;\n    })();\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}