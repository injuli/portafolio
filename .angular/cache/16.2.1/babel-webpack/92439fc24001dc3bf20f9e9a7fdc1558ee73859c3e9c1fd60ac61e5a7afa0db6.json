{"ast":null,"code":"import _asyncToGenerator from \"D:/Ingrid/Documentos/portafolio/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { executeOnSingleOrMultiple, isInArray, itemFromSingleOrMultiple, loadFont } from \"tsparticles-engine\";\nexport const validTypes = [\"text\", \"character\", \"char\"];\nexport class TextDrawer {\n  draw(context, particle, radius, opacity) {\n    const character = particle.shapeData;\n    if (character === undefined) {\n      return;\n    }\n    const textData = character.value;\n    if (textData === undefined) {\n      return;\n    }\n    if (particle.text === undefined) {\n      particle.text = itemFromSingleOrMultiple(textData, particle.randomIndexData);\n    }\n    const text = particle.text,\n      style = character.style ?? \"\",\n      weight = character.weight ?? \"400\",\n      size = Math.round(radius) * 2,\n      font = character.font ?? \"Verdana\",\n      fill = particle.fill,\n      offsetX = text.length * radius / 2;\n    context.font = `${style} ${weight} ${size}px \"${font}\"`;\n    const pos = {\n      x: -offsetX,\n      y: radius / 2\n    };\n    context.globalAlpha = opacity;\n    if (fill) {\n      context.fillText(text, pos.x, pos.y);\n    } else {\n      context.strokeText(text, pos.x, pos.y);\n    }\n    context.globalAlpha = 1;\n  }\n  getSidesCount() {\n    return 12;\n  }\n  init(container) {\n    return _asyncToGenerator(function* () {\n      const options = container.actualOptions;\n      if (validTypes.find(t => isInArray(t, options.particles.shape.type))) {\n        const shapeOptions = validTypes.map(t => options.particles.shape.options[t]).find(t => !!t),\n          promises = [];\n        executeOnSingleOrMultiple(shapeOptions, shape => {\n          promises.push(loadFont(shape.font, shape.weight));\n        });\n        yield Promise.all(promises);\n      }\n    })();\n  }\n  particleInit(container, particle) {\n    if (!particle.shape || !validTypes.includes(particle.shape)) {\n      return;\n    }\n    const character = particle.shapeData;\n    if (character === undefined) {\n      return;\n    }\n    const textData = character.value;\n    if (textData === undefined) {\n      return;\n    }\n    particle.text = itemFromSingleOrMultiple(textData, particle.randomIndexData);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}