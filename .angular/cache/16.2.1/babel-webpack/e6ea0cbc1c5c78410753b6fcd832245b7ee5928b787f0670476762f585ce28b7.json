{"ast":null,"code":"import _asyncToGenerator from \"D:/Ingrid/Documentos/portafolio/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Circle, ParticlesInteractorBase, getDistances, getLinkRandomColor } from \"tsparticles-engine\";\nimport { CircleWarp } from \"./CircleWarp\";\nimport { Links } from \"./Options/Classes/Links\";\nfunction getLinkDistance(pos1, pos2, optDistance, canvasSize, warp) {\n  const {\n    dx,\n    dy,\n    distance\n  } = getDistances(pos1, pos2);\n  if (!warp || distance <= optDistance) {\n    return distance;\n  }\n  const absDiffs = {\n      x: Math.abs(dx),\n      y: Math.abs(dy)\n    },\n    warpDistances = {\n      x: Math.min(absDiffs.x, canvasSize.width - absDiffs.x),\n      y: Math.min(absDiffs.y, canvasSize.height - absDiffs.y)\n    };\n  return Math.sqrt(warpDistances.x ** 2 + warpDistances.y ** 2);\n}\nexport class Linker extends ParticlesInteractorBase {\n  constructor(container) {\n    super(container);\n    this._setColor = p1 => {\n      if (!p1.options.links) {\n        return;\n      }\n      const container = this.linkContainer,\n        linksOptions = p1.options.links;\n      let linkColor = linksOptions.id === undefined ? container.particles.linksColor : container.particles.linksColors.get(linksOptions.id);\n      if (linkColor) {\n        return;\n      }\n      const optColor = linksOptions.color;\n      linkColor = getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);\n      if (linksOptions.id === undefined) {\n        container.particles.linksColor = linkColor;\n      } else {\n        container.particles.linksColors.set(linksOptions.id, linkColor);\n      }\n    };\n    this.linkContainer = container;\n  }\n  clear() {}\n  init() {\n    this.linkContainer.particles.linksColor = undefined;\n    this.linkContainer.particles.linksColors = new Map();\n  }\n  interact(p1) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!p1.options.links) {\n        return;\n      }\n      p1.links = [];\n      const pos1 = p1.getPosition(),\n        container = _this.container,\n        canvasSize = container.canvas.size;\n      if (pos1.x < 0 || pos1.y < 0 || pos1.x > canvasSize.width || pos1.y > canvasSize.height) {\n        return;\n      }\n      const linkOpt1 = p1.options.links,\n        optOpacity = linkOpt1.opacity,\n        optDistance = p1.retina.linksDistance ?? 0,\n        warp = linkOpt1.warp,\n        range = warp ? new CircleWarp(pos1.x, pos1.y, optDistance, canvasSize) : new Circle(pos1.x, pos1.y, optDistance),\n        query = container.particles.quadTree.query(range);\n      for (const p2 of query) {\n        const linkOpt2 = p2.options.links;\n        if (p1 === p2 || !linkOpt2?.enable || linkOpt1.id !== linkOpt2.id || p2.spawning || p2.destroyed || !p2.links || p1.links.some(t => t.destination === p2) || p2.links.some(t => t.destination === p1)) {\n          continue;\n        }\n        const pos2 = p2.getPosition();\n        if (pos2.x < 0 || pos2.y < 0 || pos2.x > canvasSize.width || pos2.y > canvasSize.height) {\n          continue;\n        }\n        const distance = getLinkDistance(pos1, pos2, optDistance, canvasSize, warp && linkOpt2.warp);\n        if (distance > optDistance) {\n          continue;\n        }\n        const opacityLine = (1 - distance / optDistance) * optOpacity;\n        _this._setColor(p1);\n        p1.links.push({\n          destination: p2,\n          opacity: opacityLine\n        });\n      }\n    })();\n  }\n  isEnabled(particle) {\n    return !!particle.options.links?.enable;\n  }\n  loadParticlesOptions(options, ...sources) {\n    if (!options.links) {\n      options.links = new Links();\n    }\n    for (const source of sources) {\n      options.links.load(source?.links ?? source?.lineLinked ?? source?.line_linked);\n    }\n  }\n  reset() {}\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}