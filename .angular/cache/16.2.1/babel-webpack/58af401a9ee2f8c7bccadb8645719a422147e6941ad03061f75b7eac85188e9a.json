{"ast":null,"code":"import _asyncToGenerator from \"D:/Ingrid/Documentos/portafolio/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _parseExtensionBlock, _parseImageBlock, _parseBlock, _decodeGIF;\nimport { InterlaceOffsets, InterlaceSteps } from \"./Constants\";\nimport { ByteStream } from \"./ByteStream\";\nfunction parseColorTable(byteStream, count) {\n  const colors = [];\n  for (let i = 0; i < count; i++) {\n    colors.push({\n      r: byteStream.data[byteStream.pos],\n      g: byteStream.data[byteStream.pos + 1],\n      b: byteStream.data[byteStream.pos + 2]\n    });\n    byteStream.pos += 3;\n  }\n  return colors;\n}\nfunction parseExtensionBlock(_x, _x2, _x3, _x4) {\n  return (_parseExtensionBlock = _parseExtensionBlock || _asyncToGenerator(function* (byteStream, gif, getFrameIndex, getTransparencyIndex) {\n    switch (byteStream.nextByte()) {\n      case 249:\n        {\n          const frame = gif.frames[getFrameIndex(false)];\n          byteStream.pos++;\n          const packedByte = byteStream.nextByte();\n          frame.GCreserved = (packedByte & 0xe0) >>> 5;\n          frame.disposalMethod = (packedByte & 0x1c) >>> 2;\n          frame.userInputDelayFlag = (packedByte & 2) === 2;\n          const transparencyFlag = (packedByte & 1) === 1;\n          frame.delayTime = byteStream.nextTwoBytes() * 0xa;\n          const transparencyIndex = byteStream.nextByte();\n          if (transparencyFlag) {\n            getTransparencyIndex(transparencyIndex);\n          }\n          byteStream.pos++;\n          break;\n        }\n      case 255:\n        {\n          byteStream.pos++;\n          const applicationExtension = {\n            identifier: byteStream.getString(8),\n            authenticationCode: byteStream.getString(3),\n            data: byteStream.readSubBlocksBin()\n          };\n          gif.applicationExtensions.push(applicationExtension);\n          break;\n        }\n      case 254:\n        {\n          gif.comments.push([getFrameIndex(false), byteStream.readSubBlocks()]);\n          break;\n        }\n      case 1:\n        {\n          if (gif.globalColorTable.length === 0) {\n            throw new EvalError(\"plain text extension without global color table\");\n          }\n          byteStream.pos++;\n          gif.frames[getFrameIndex(false)].plainTextData = {\n            left: byteStream.nextTwoBytes(),\n            top: byteStream.nextTwoBytes(),\n            width: byteStream.nextTwoBytes(),\n            height: byteStream.nextTwoBytes(),\n            charSize: {\n              width: byteStream.nextTwoBytes(),\n              height: byteStream.nextTwoBytes()\n            },\n            foregroundColor: byteStream.nextByte(),\n            backgroundColor: byteStream.nextByte(),\n            text: byteStream.readSubBlocks()\n          };\n          break;\n        }\n      default:\n        byteStream.skipSubBlocks();\n        break;\n    }\n  })).apply(this, arguments);\n}\nfunction parseImageBlock(_x5, _x6, _x7, _x8, _x9, _x10) {\n  return (_parseImageBlock = _parseImageBlock || _asyncToGenerator(function* (byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    const frame = gif.frames[getFrameIndex(true)];\n    frame.left = byteStream.nextTwoBytes();\n    frame.top = byteStream.nextTwoBytes();\n    frame.width = byteStream.nextTwoBytes();\n    frame.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(),\n      localColorTableFlag = (packedByte & 0x80) === 0x80,\n      interlacedFlag = (packedByte & 0x40) === 0x40;\n    frame.sortFlag = (packedByte & 0x20) === 0x20;\n    frame.reserved = (packedByte & 0x18) >>> 3;\n    const localColorCount = 1 << (packedByte & 7) + 1;\n    if (localColorTableFlag) {\n      frame.localColorTable = parseColorTable(byteStream, localColorCount);\n    }\n    const getColor = index => {\n      const {\n        r,\n        g,\n        b\n      } = (localColorTableFlag ? frame.localColorTable : gif.globalColorTable)[index];\n      return {\n        r,\n        g,\n        b,\n        a: index === getTransparencyIndex(null) ? avgAlpha ? ~~((r + g + b) / 3) : 0 : 255\n      };\n    };\n    const image = (() => {\n      try {\n        return new ImageData(frame.width, frame.height, {\n          colorSpace: \"srgb\"\n        });\n      } catch (error) {\n        if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n          return null;\n        }\n        throw error;\n      }\n    })();\n    if (image == null) {\n      throw new EvalError(\"GIF frame size is to large\");\n    }\n    const minCodeSize = byteStream.nextByte(),\n      imageData = byteStream.readSubBlocksBin(),\n      clearCode = 1 << minCodeSize;\n    const readBits = (pos, len) => {\n      const bytePos = pos >>> 3,\n        bitPos = pos & 7;\n      return (imageData[bytePos] + (imageData[bytePos + 1] << 8) + (imageData[bytePos + 2] << 16) & (1 << len) - 1 << bitPos) >>> bitPos;\n    };\n    if (interlacedFlag) {\n      for (let code = 0, size = minCodeSize + 1, pos = 0, dic = [[0]], pass = 0; pass < 4; pass++) {\n        if (InterlaceOffsets[pass] < frame.height) {\n          for (let pixelPos = 0, lineIndex = 0;;) {\n            const last = code;\n            code = readBits(pos, size);\n            pos += size + 1;\n            if (code === clearCode) {\n              size = minCodeSize + 1;\n              dic.length = clearCode + 2;\n              for (let i = 0; i < dic.length; i++) {\n                dic[i] = i < clearCode ? [i] : [];\n              }\n            } else {\n              if (code >= dic.length) {\n                dic.push(dic[last].concat(dic[last][0]));\n              } else if (last !== clearCode) {\n                dic.push(dic[last].concat(dic[code][0]));\n              }\n              for (let i = 0; i < dic[code].length; i++) {\n                const {\n                  r,\n                  g,\n                  b,\n                  a\n                } = getColor(dic[code][i]);\n                image.data.set([r, g, b, a], InterlaceOffsets[pass] * frame.width + InterlaceSteps[pass] * lineIndex + pixelPos % (frame.width * 4));\n                pixelPos += 4;\n              }\n              if (dic.length === 1 << size && size < 0xc) {\n                size++;\n              }\n            }\n            if (pixelPos === frame.width * 4 * (lineIndex + 1)) {\n              lineIndex++;\n              if (InterlaceOffsets[pass] + InterlaceSteps[pass] * lineIndex >= frame.height) {\n                break;\n              }\n            }\n          }\n        }\n        progressCallback?.(byteStream.pos / (byteStream.data.length - 1), getFrameIndex(false) + 1, image, {\n          x: frame.left,\n          y: frame.top\n        }, {\n          width: gif.width,\n          height: gif.height\n        });\n      }\n      frame.image = image;\n      frame.bitmap = yield createImageBitmap(image);\n    } else {\n      for (let code = 0, size = minCodeSize + 1, pos = 0, dic = [[0]], pixelPos = -4;;) {\n        const last = code;\n        code = readBits(pos, size);\n        pos += size;\n        if (code === clearCode) {\n          size = minCodeSize + 1;\n          dic.length = clearCode + 2;\n          for (let i = 0; i < dic.length; i++) {\n            dic[i] = i < clearCode ? [i] : [];\n          }\n        } else {\n          if (code === clearCode + 1) {\n            break;\n          }\n          if (code >= dic.length) {\n            dic.push(dic[last].concat(dic[last][0]));\n          } else if (last !== clearCode) {\n            dic.push(dic[last].concat(dic[code][0]));\n          }\n          for (let i = 0; i < dic[code].length; i++) {\n            const {\n              r,\n              g,\n              b,\n              a\n            } = getColor(dic[code][i]);\n            image.data.set([r, g, b, a], pixelPos += 4);\n          }\n          if (dic.length >= 1 << size && size < 0xc) {\n            size++;\n          }\n        }\n      }\n      frame.image = image;\n      frame.bitmap = yield createImageBitmap(image);\n      progressCallback?.((byteStream.pos + 1) / byteStream.data.length, getFrameIndex(false) + 1, frame.image, {\n        x: frame.left,\n        y: frame.top\n      }, {\n        width: gif.width,\n        height: gif.height\n      });\n    }\n  })).apply(this, arguments);\n}\nfunction parseBlock(_x11, _x12, _x13, _x14, _x15, _x16) {\n  return (_parseBlock = _parseBlock || _asyncToGenerator(function* (byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    switch (byteStream.nextByte()) {\n      case 59:\n        return true;\n      case 44:\n        yield parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback);\n        break;\n      case 33:\n        yield parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex);\n        break;\n      default:\n        throw new EvalError(\"undefined block found\");\n    }\n    return false;\n  })).apply(this, arguments);\n}\nexport function getGIFLoopAmount(gif) {\n  for (const extension of gif.applicationExtensions) {\n    if (extension.identifier + extension.authenticationCode !== \"NETSCAPE2.0\") {\n      continue;\n    }\n    return extension.data[1] + (extension.data[2] << 8);\n  }\n  return NaN;\n}\nexport function decodeGIF(_x17, _x18, _x19) {\n  return (_decodeGIF = _decodeGIF || _asyncToGenerator(function* (gifURL, progressCallback, avgAlpha) {\n    if (!avgAlpha) avgAlpha = false;\n    const res = yield fetch(gifURL);\n    if (!res.ok && res.status === 404) {\n      throw new EvalError(\"file not found\");\n    }\n    const buffer = yield res.arrayBuffer();\n    const gif = {\n        width: 0,\n        height: 0,\n        totalTime: 0,\n        colorRes: 0,\n        pixelAspectRatio: 0,\n        frames: [],\n        sortFlag: false,\n        globalColorTable: [],\n        backgroundImage: new ImageData(1, 1, {\n          colorSpace: \"srgb\"\n        }),\n        comments: [],\n        applicationExtensions: []\n      },\n      byteStream = new ByteStream(new Uint8ClampedArray(buffer));\n    if (byteStream.getString(6) !== \"GIF89a\") {\n      throw new Error(\"not a supported GIF file\");\n    }\n    gif.width = byteStream.nextTwoBytes();\n    gif.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(),\n      globalColorTableFlag = (packedByte & 0x80) === 0x80;\n    gif.colorRes = (packedByte & 0x70) >>> 4;\n    gif.sortFlag = (packedByte & 8) === 8;\n    const globalColorCount = 1 << (packedByte & 7) + 1,\n      backgroundColorIndex = byteStream.nextByte();\n    gif.pixelAspectRatio = byteStream.nextByte();\n    if (gif.pixelAspectRatio !== 0) {\n      gif.pixelAspectRatio = (gif.pixelAspectRatio + 0xf) / 0x40;\n    }\n    if (globalColorTableFlag) {\n      gif.globalColorTable = parseColorTable(byteStream, globalColorCount);\n    }\n    const backgroundImage = (() => {\n      try {\n        return new ImageData(gif.width, gif.height, {\n          colorSpace: \"srgb\"\n        });\n      } catch (error) {\n        if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n          return null;\n        }\n        throw error;\n      }\n    })();\n    if (backgroundImage == null) {\n      throw new Error(\"GIF frame size is to large\");\n    }\n    const {\n      r,\n      g,\n      b\n    } = gif.globalColorTable[backgroundColorIndex];\n    backgroundImage.data.set(globalColorTableFlag ? [r, g, b, 255] : [0, 0, 0, 0]);\n    for (let i = 4; i < backgroundImage.data.length; i *= 2) {\n      backgroundImage.data.copyWithin(i, 0, i);\n    }\n    gif.backgroundImage = backgroundImage;\n    let frameIndex = -1,\n      incrementFrameIndex = true,\n      transparencyIndex = -1;\n    const getframeIndex = increment => {\n      if (increment) {\n        incrementFrameIndex = true;\n      }\n      return frameIndex;\n    };\n    const getTransparencyIndex = newValue => {\n      if (newValue != null) {\n        transparencyIndex = newValue;\n      }\n      return transparencyIndex;\n    };\n    try {\n      do {\n        if (incrementFrameIndex) {\n          gif.frames.push({\n            left: 0,\n            top: 0,\n            width: 0,\n            height: 0,\n            disposalMethod: 0,\n            image: new ImageData(1, 1, {\n              colorSpace: \"srgb\"\n            }),\n            plainTextData: null,\n            userInputDelayFlag: false,\n            delayTime: 0,\n            sortFlag: false,\n            localColorTable: [],\n            reserved: 0,\n            GCreserved: 0\n          });\n          frameIndex++;\n          transparencyIndex = -1;\n          incrementFrameIndex = false;\n        }\n      } while (!(yield parseBlock(byteStream, gif, avgAlpha, getframeIndex, getTransparencyIndex, progressCallback)));\n      gif.frames.length--;\n      for (const frame of gif.frames) {\n        if (frame.userInputDelayFlag && frame.delayTime === 0) {\n          gif.totalTime = Infinity;\n          break;\n        }\n        gif.totalTime += frame.delayTime;\n      }\n      return gif;\n    } catch (error) {\n      if (error instanceof EvalError) {\n        throw new Error(`error while parsing frame ${frameIndex} \"${error.message}\"`);\n      }\n      throw error;\n    }\n  })).apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}